import React,{useContext,useMemo,useRef,useReducer,useEffect}from"react";import jsutils,{noPropArr,eitherArr,get,clearObj,noOpObj,snakeCase,isFunc,checkCall,isObj,camelCase,deepMerge}from"@keg-hub/jsutils";import io from"socket.io-client";function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _extends(){return(_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target}).apply(this,arguments)}const SocketContext=React.createContext(null),useSockr=()=>useContext(SocketContext),SockrHoc=Component=>{const websocket=useSockr();return props=>React.createElement(Component,_extends({},props,{websocket:websocket}))};let _SOCKR_STATE,_SOCKR_DISPATCH=()=>console.warn("Sockr Dispatch has not been initialized!");const getState=()=>_SOCKR_STATE,getDispatch=()=>_SOCKR_DISPATCH,setNextState=next=>{_SOCKR_STATE=next},useSockrItems=(findPaths=noPropArr)=>{const statePaths=eitherArr(findPaths,[findPaths]),state=getState(),values=useMemo((()=>statePaths.reduce(((found,valPath)=>(found[valPath]=get(state,valPath),found)),{})),[state,statePaths]),sockrRef=useRef(values);return useMemo((()=>(clearObj(sockrRef.current),Object.entries(values).map((([key,value])=>sockrRef.current[key]=value)),sockrRef.current)),[values,sockrRef&&sockrRef.current])},{deepFreeze:deepFreeze}=jsutils;var eventTypes={EventTypes:deepFreeze({INIT:"SOCKr:INIT",SET_ID:"SOCKr:SET_ID",CONNECT:"SOCKr:CONNECT",UPDATE_STORE:"SOCKr:UPDATE_STORE",AUTH_TOKEN:"SOCKr:AUTH_TOKEN",NOT_AUTHORIZED:"SOCKr:NOT_AUTHORIZED",ADD_PEER:"SOCKr:ADD_PEER",PEER_DISCONNECT:"SOCKr:PEER_DISCONNECT",SET_CMDS:"SOCKr:SET_CMDS",RUN_CMD:"SOCKr:RUN_CMD",CMD_RUNNING:"SOCKr:CMD_RUNNING",CMD_END:"SOCKr:CMD_END",CMD_OUT:"SOCKr:CMD_OUT",CMD_ERR:"SOCKr:CMD_ERR",CMD_FAIL:"SOCKr:CMD_FAIL"}),tagPrefix:"SOCKr"},eventTypes_1=eventTypes.EventTypes,eventTypes_2=eventTypes.tagPrefix;const setId=({id:id,data:data,isRunning:isRunning})=>{getDispatch()({type:eventTypes_1.SET_ID,id:id,isRunning:isRunning,...data})},setCmds=({data:{commands:commands}})=>getDispatch()({commands:commands,type:eventTypes_1.SET_CMDS});var InternalActions=Object.freeze({__proto__:null,addPeer:({id:id,peers:peers})=>getDispatch()({type:eventTypes_1.ADD_PEER,id:id,peers:peers}),init:(data=noOpObj,service=noOpObj)=>{setCmds(data),setId(data)},connect:()=>getDispatch()({type:eventTypes_1.CONNECT,connected:!0}),cmdEnd:data=>data&&data.message&&getDispatch()({type:eventTypes_1.CMD_END,...data}),cmdErr:data=>{data&&data.message&&getDispatch()({type:eventTypes_1.CMD_ERR,...data})},cmdFail:(data,service)=>data&&data.message&&getDispatch()({type:eventTypes_1.CMD_FAIL,...data}),cmdOut:data=>{data&&data.message&&getDispatch()({type:eventTypes_1.CMD_OUT,...data})},peerDisconnect:({id:id,peers:peers})=>getDispatch()({type:eventTypes_1.DISCONNECT_PEER,id:id,peers:peers}),setId:setId,setCmds:setCmds,toggleIsRunning:({isRunning:isRunning,name:name})=>{getDispatch()({type:eventTypes_1.RUNNING,isRunning:isRunning,name:name})}});const checkCallEvent=(action,message,instance,event)=>checkCall(action,message,instance,event),callAction=(instance,event,action)=>{const eventName=camelCase((event.split(":")[1]||"").toLowerCase());return data=>{if(!eventName)return instance.logData("Invalid event name!",event);const message=data&&JSON.parse(data);instance.logEvent(event,message),"init"===eventName&&(instance.commands=get(message,"data.commands"));const internal=InternalActions[eventName];internal&&checkCallEvent(internal,message,instance,event);const customEvent=get(instance.config,`events.${eventName}`);customEvent&&checkCallEvent(customEvent,message,instance,event);const allEvent=get(instance.config,"events.all");allEvent&&checkCallEvent(allEvent,message,instance,event)}};class SocketService{constructor(){_defineProperty(this,"emit",((event,data)=>this.socket?event?(this.logData(`Sending Socket Event: ${event}`,data),void this.socket.emit(event,data)):console.error("Event type is missing, cannot emit socket event without an event type!",event):console.error("Socket not connected, cannot emit socket event!"))),_defineProperty(this,"disconnect",(()=>{if(!this.socket)return this.logData("Socket already disconnected!");this.logData("Disconnecting from Socket!"),this.socket.disconnect(),this.socket=void 0,this.config=void 0,this.dispatch=void 0}))}logData(...data){this.logDebug&&console.log(...data)}logEvent(event,...data){this.logDebug&&console.log(`Socket Event: ${event}`,...data)}initSocket(config,token,logDebug=!1){if(this.socket)return;this.config=config,this.logDebug=logDebug;const endpoint=(config=>{const protocol=get(window,"location.protocol","https:");return config.port?`${protocol}//${config.host}:${config.port}`:config.host})(config);this.logData(`Connecting to backend socket => ${endpoint}${config.path}`),this.socket=io(endpoint,{path:config.path,transports:["websocket","polling","flashsocket"]}),this.addEvents(token)}addEvents(token){this.socket&&(Object.entries(get(this.config,"events",noOpObj)).map((([name,action])=>{const namCaps=snakeCase(name).toUpperCase();if("ALL"===namCaps)return;const eventType=`${eventTypes_2}:${namCaps}`;isFunc(action)&&!eventTypes_1[namCaps]&&this.socket.on(eventType,callAction(this,eventType))})),Object.entries(eventTypes_1).map((([key,eventType])=>{this.socket.on(eventType,callAction(this,eventType))})),this.socket.on("connect",this.onConnection.bind(this,token)))}onConnection(token,data){callAction(this,`${eventTypes_2}:CONNECT`)(data)}runCommand(command,params){const{id:id,cmd:cmd,name:name,group:group}=((commands,cmdOrId)=>{const cmdId=isObj(cmdOrId)?cmdOrId.id:cmdOrId;return Object.entries(commands).reduce(((found,[group,subCmds])=>found||Object.entries(subCmds).reduce(((subFound,[name,definition])=>!subFound&&isObj(definition)&&definition.id===cmdId?definition:subFound),!1)),!1)})(this.commands,command);return this.emit(eventTypes_1.RUN_CMD,{id:id,cmd:cmd,name:name,group:group,params:params})}}const WSService=new SocketService,initialState={connected:!1,peers:[],id:null,runningCmd:null,isRunning:!1,server:noOpObj,events:noOpObj},sockrReducer=(state=initialState,action)=>{if(!state||!action||!action.type)return state;switch(action.type){case eventTypes_1.CONNECT:return action.connected===state.connected?state:{...state,connected:!0};case eventTypes_1.SET_ID:{const{type:type,...updates}=action;return action.id?{...state,...updates}:state}case eventTypes_1.RUNNING:return action.isRunning===state.isRunning?state:{...state,runningCmd:action.isRunning&&action.name||null,isRunning:action.isRunning};case eventTypes_1.ADD_PEER:case eventTypes_1.DISCONNECT_PEER:return action.peers?{...state,peers:action.peers}:state;default:return state}};let _JOINED_REDUCERS;const initialState$1=sockrReducer();setNextState(initialState$1);const useSockrReducer=(customReducer,customInitialState)=>{const[state,dispatch]=useReducer(((sockrReducer,customReducer)=>_JOINED_REDUCERS||(_JOINED_REDUCERS=(state,action)=>{const updatedState=sockrReducer(state,action);return customReducer(updatedState,action)},_JOINED_REDUCERS))(sockrReducer,customReducer),deepMerge(initialState$1,customInitialState));return getState()!==state&&setNextState(state),getDispatch()!==dispatch&&(dispatch=>{_SOCKR_DISPATCH=dispatch})(dispatch),state},isDev="development"===process.env.NODE_ENV,MemoChildren=React.memo((props=>React.createElement(React.Fragment,null,props.children))),SockrProvider=props=>{const{children:children,config:config,reducer:reducer,token:token,debug:debug}=props,websocket=useSockrReducer(reducer,config||noOpObj);return useEffect((()=>(WSService&&!WSService.socket&&WSService.initSocket(websocket,token,debug),()=>!isDev&&WSService.disconnect())),[]),React.createElement(SocketContext.Provider,{value:websocket},React.createElement(MemoChildren,null,children))};var constants={...eventTypes};const{EventTypes:EventTypes$1,tagPrefix:tagPrefix}=constants;export{EventTypes$1 as EventTypes,SocketService,SockrHoc,SockrProvider,WSService,tagPrefix,useSockr,useSockrItems};
//# sourceMappingURL=index.js.map
