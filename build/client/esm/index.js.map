{"version":3,"file":"index.js","sources":["../../../src/client/context/context.js","../../../src/client/hooks/useSockr.js","../../../src/client/hocs/sockrHoc.js","../../../src/client/reducer/sockrState.js","../../../src/client/hooks/useSockrItems.js","../../../src/constants/eventTypes.js","../../../src/client/actions/addPeer.js","../../../src/client/actions/setId.js","../../../src/client/actions/setCmds.js","../../../src/client/actions/init.js","../../../src/client/actions/connect.js","../../../src/client/actions/cmdEnd.js","../../../src/client/actions/cmdErr.js","../../../src/client/actions/cmdFail.js","../../../src/client/actions/cmdOut.js","../../../src/client/actions/peerDisconnect.js","../../../src/client/actions/toggleIsRunning.js","../../../src/client/service/socketService.js","../../../src/client/reducer/sockrReducer.js","../../../src/client/reducer/joinReducers.js","../../../src/client/reducer/useSockrReducer.js","../../../src/client/context/SockrProvider.js","../../../src/constants/index.js","../../../src/client/index.js"],"sourcesContent":["import React from 'react'\n\n/**\n * Creates the initial theme context\n */\nexport const SocketContext = React.createContext(null)\n","import { SocketContext } from '../context/context'\nimport { useContext } from 'react'\n\n/**\n * Helper hook to get the websocket content\n * @function\n * @public\n * @export\n *\n * @returns {Object} websocket context object\n */\nexport const useSockr = () => {\n  return useContext(SocketContext)\n}\n","import { useSockr } from '../hooks/useSockr'\nimport React from 'react'\n\n/**\n * Websocket HOC component\n * @function\n * @public\n * @export\n * @param {Object} props\n *\n */\nexport const SockrHoc = Component => {\n  const websocket = useSockr()\n  return props => <Component {...props} websocket={websocket} />\n}\n","/**\n * Cache holder for the sockr sate object\n * Should be update every time the sockr reducer state is changed\n * @type Object\n * @private\n *\n */\nlet _SOCKR_STATE\n\n/**\n * Cache holder for the sockr dispatch method\n * @function\n * @private\n *\n * @returns {void}\n */\nlet _SOCKR_DISPATCH = () =>\n  console.warn(`Sockr Dispatch has not been initialized!`)\n\n/**\n * Helper to get the sockrDispatch method\n * @function\n * @public\n * @export\n *\n * @returns {function} Sockr dispatch method\n */\nexport const getState = () => _SOCKR_STATE\n\n/**\n * Helper to get the sockrDispatch method\n * @function\n * @public\n * @export\n *\n * @returns {function} Sockr dispatch method\n */\nexport const getDispatch = () => _SOCKR_DISPATCH\n\n/**\n * Sets the internally managed sockr state object\n * @function\n * @public\n * @export\n * @param {Object} next - The next state object\n *\n * @returns {void}\n */\nexport const setNextState = next => {\n  _SOCKR_STATE = next\n}\n\n/**\n * Sets the internally managed sockr dispatch function\n * @function\n * @public\n * @export\n * @param {function} dispatch - The store dispatch function\n *\n * @returns {void}\n */\nexport const setDispatch = dispatch => {\n  _SOCKR_DISPATCH = dispatch\n}\n\n/**\n * Helper matching the redux API to get the getState and getDispatch methods\n * @function\n * @public\n * @export\n * @param {function} dispatch - The store dispatch function\n *\n * @returns {void}\n */\nexport const getStore = () => {\n  return {\n    getState,\n    getDispatch,\n  }\n}\n","import { useMemo, useRef } from 'react'\nimport { getState } from '../reducer/sockrState'\nimport { get, noPropArr, clearObj, eitherArr } from '@keg-hub/jsutils'\n\n/**\n * Hook to extract a single values from the sockr state object\n * Memoizes the extracted values and returns them as an object\n * Only updates the values when the store property matching a key statePaths has updated\n * This avoids re-renders when the state object has change, but a value has not\n * @function\n * @public\n * @export\n * @returns {Array} statePaths - Paths to values on the current sockr state\n *\n * @returns {Object} Memoize values from the state\n */\nexport const useSockrItems = (findPaths = noPropArr) => {\n  // Ensure we have an array to call reduce on\n  const statePaths = eitherArr(findPaths, [findPaths])\n\n  // Get the current state to allow pulling the values with statePaths\n  const state = getState()\n\n  // Memoize the current values from the state at statePaths\n  // If the state updates, but not the values from statePaths,\n  // then this hook with run, but the returned values will be the same\n  // Or it will get the updated values when the state has changes\n  // Either way, the values should always be the correct values in the state\n  const values = useMemo(() => {\n    return statePaths.reduce((found, valPath) => {\n      found[valPath] = get(state, valPath)\n\n      return found\n    }, {})\n  }, [ state, statePaths ])\n\n  // Init the sockrRef to store the initial value\n  const sockrRef = useRef(values)\n\n  // Memoize the values and sockrRef.current\n  // Loop each property in values and\n  // Update sockrRef.current to the current state value\n  // Then return sockrRef.current\n  // This way the values are only ever updated it it's they changed on that state changed\n  // If the state object changes, but not the values, then the original values are returned\n  return useMemo(() => {\n    // Clear out all keys from the current ref\n    // This also keeps the same identity of the ref object\n    // Which means we should check the children for updates, not the root object\n    clearObj(sockrRef.current)\n\n    // Loop the values and add the current values to the ref\n    // This puts back any values we removed in the clearObj method call\n    // If the value never changed, then the ref should have the same value again\n    // But it removes any properties that should not longer exist\n    Object.entries(values).map(\n      ([ key, value ]) => (sockrRef.current[key] = value)\n    )\n\n    return sockrRef.current\n  }, [ values, sockrRef && sockrRef.current ])\n}\n","const { deepFreeze } = require('@keg-hub/jsutils')\n\nconst TAG_PREFIX = 'SOCKr'\n\nconst EventTypes = deepFreeze({\n  // General\n  INIT: `${TAG_PREFIX}:INIT`,\n  SET_ID: `${TAG_PREFIX}:SET_ID`,\n  CONNECT: `${TAG_PREFIX}:CONNECT`,\n\n  // STORE\n  UPDATE_STORE: `${TAG_PREFIX}:UPDATE_STORE`,\n\n  // Auth\n  AUTH_TOKEN: `${TAG_PREFIX}:AUTH_TOKEN`,\n  NOT_AUTHORIZED: `${TAG_PREFIX}:NOT_AUTHORIZED`,\n\n  // Peer\n  ADD_PEER: `${TAG_PREFIX}:ADD_PEER`,\n  PEER_DISCONNECT: `${TAG_PREFIX}:PEER_DISCONNECT`,\n\n  // Command\n  SET_CMDS: `${TAG_PREFIX}:SET_CMDS`,\n  RUN_CMD: `${TAG_PREFIX}:RUN_CMD`,\n  CMD_RUNNING: `${TAG_PREFIX}:CMD_RUNNING`,\n  CMD_END: `${TAG_PREFIX}:CMD_END`,\n  CMD_OUT: `${TAG_PREFIX}:CMD_OUT`,\n  CMD_ERR: `${TAG_PREFIX}:CMD_ERR`,\n  CMD_FAIL: `${TAG_PREFIX}:CMD_FAIL`,\n})\n\nmodule.exports = {\n  EventTypes,\n  tagPrefix: TAG_PREFIX,\n}\n","import { getDispatch } from '../reducer/sockrState'\nimport { EventTypes } from '../../constants/eventTypes'\n\n/**\n * Dispatches a connected peers id\n * @param {Object} id - Id of the peer that has connected\n * @param {Array} peers - Currently connected peers\n *\n * @returns {void}\n */\nexport const addPeer = ({ id, peers }) => {\n  return getDispatch()({\n    type: EventTypes.ADD_PEER,\n    id,\n    peers,\n  })\n}\n","import { getDispatch } from '../reducer/sockrState'\nimport { EventTypes } from '../../constants/eventTypes'\n\n/**\n * Dispatches that a peer has disconnected\n * @param {Object} id - Id of the connected socket\n * @param {Boolean} isRunning - Is the backend running a command\n * @param {Boolean} data - Extra metadata sent from the backend\n *\n * @returns {void}\n */\nexport const setId = ({ id, data, isRunning }) => {\n  getDispatch()({\n    type: EventTypes.SET_ID,\n    id,\n    isRunning,\n    ...data,\n  })\n}\n","import { getDispatch } from '../reducer/sockrState'\nimport { EventTypes } from '../../constants/eventTypes'\n\n/**\n * Dispatches passed in commands to the reducers\n * @param {Object} data - Message data from the socket\n *\n * @returns {void}\n */\nexport const setCmds = ({ data: { commands } }) => {\n  return getDispatch()({\n    commands,\n    type: EventTypes.SET_CMDS,\n  })\n}\n","import { noOpObj } from '@keg-hub/jsutils'\nimport { setId } from './setId'\nimport { setCmds } from './setCmds'\n\n/**\n * Initializes the store when the web-socket is initialised\n * Makes call to store the allowed commands and sets the sockets id\n * @param {Object} data - Message data from the socket\n *\n * @returns {void}\n */\nexport const init = (data = noOpObj, service = noOpObj) => {\n  setCmds(data, service)\n  setId(data, service)\n}\n","import { getDispatch } from '../reducer/sockrState'\nimport { EventTypes } from '../../constants/eventTypes'\n\n/**\n * Dispatches event that the web-socket has connected\n *\n * @returns {void}\n */\nexport const connect = () => {\n  return getDispatch()({\n    type: EventTypes.CONNECT,\n    connected: true,\n  })\n}\n","import { getDispatch } from '../reducer/sockrState'\nimport { toggleIsRunning } from './toggleIsRunning'\nimport { EventTypes } from '../../constants/eventTypes'\n\n/**\n * Dispatches when a command has finished running\n * Makes call to toggleIsRunning, to turn it off\n * @param {Object} data - Message data from the socket\n *\n * @returns {void}\n */\nexport const cmdEnd = data => {\n  return (\n    data &&\n    data.message &&\n    getDispatch()({\n      type: EventTypes.CMD_END,\n      ...data,\n    })\n  )\n\n  toggleIsRunning(data)\n}\n","import { getDispatch } from '../reducer/sockrState'\nimport { EventTypes } from '../../constants/eventTypes'\n\n/**\n * Dispatches an error message that occurred on while a command was running\n * @param {Object} data - Message data from the socket\n *\n * @returns {void}\n */\nexport const cmdErr = data => {\n  data &&\n    data.message &&\n    getDispatch()({\n      type: EventTypes.CMD_ERR,\n      ...data,\n    })\n}\n","import { getDispatch } from '../reducer/sockrState'\nimport { toggleIsRunning } from './toggleIsRunning'\nimport { EventTypes } from '../../constants/eventTypes'\n\n/**\n * Dispatches an error that occurred on while a command was running\n * Makes call to toggleIsRunning, to turn it off\n * @param {Object} data - Message data from the socket\n *\n * @returns {void}\n */\nexport const cmdFail = (data, service) => {\n  return (\n    data &&\n    data.message &&\n    getDispatch()({\n      type: EventTypes.CMD_FAIL,\n      ...data,\n    })\n  )\n\n  toggleIsRunning(data, service)\n}\n","import { getDispatch } from '../reducer/sockrState'\nimport { EventTypes } from '../../constants/eventTypes'\n\n/**\n * Dispatches an output message that occurred on while a command was running\n * @param {Object} data - Message data from the socket\n *\n * @returns {void}\n */\nexport const cmdOut = data => {\n  data &&\n    data.message &&\n    getDispatch()({\n      type: EventTypes.CMD_OUT,\n      ...data,\n    })\n}\n","import { getDispatch } from '../reducer/sockrState'\nimport { EventTypes } from '../../constants/eventTypes'\n\n/**\n * Dispatches that a peer has disconnected\n * @param {Object} id - Id of the peer that has disconnected\n * @param {Array} peers - Currently connected peers\n *\n * @returns {void}\n */\nexport const peerDisconnect = ({ id, peers }) => {\n  return getDispatch()({\n    type: EventTypes.DISCONNECT_PEER,\n    id,\n    peers,\n  })\n}\n","import { getDispatch } from '../reducer/sockrState'\nimport { EventTypes } from '../../constants/eventTypes'\n\n/**\n * Toggles if the backend is running a command\n * @param {Boolean} isRunning - Is the backend running a command\n * @param {string} name - Name of the command being run\n *\n * @returns {void}\n */\nexport const toggleIsRunning = ({ isRunning, name }) => {\n  getDispatch()({\n    type: EventTypes.RUNNING,\n    isRunning,\n    name,\n  })\n}\n","import io from 'socket.io-client'\nimport {\n  checkCall,\n  get,\n  isFunc,\n  noOpObj,\n  camelCase,\n  snakeCase,\n  isObj,\n} from '@keg-hub/jsutils'\nimport { EventTypes, tagPrefix } from '../../constants/eventTypes'\nimport * as InternalActions from '../actions'\n\n/**\n * Builds the websocket endpoint to connect to the backend websocket\n * @function\n * @private\n *\n * @param {Object} config - Websocket client config object matching the config spec\n *\n * @returns {string} - Built websocket endpoint\n */\nconst buildEndpoint = config => {\n  // Use the same http protocol as what the current window is using\n  const protocol = get(window, 'location.protocol', 'https:')\n  return config.port\n    ? `${protocol}//${config.host}:${config.port}`\n    : config.host\n}\n\n/**\n * Calls the passed in actions with the received message and SocketService class instance\n * @function\n * @private\n *\n * @param {function} action - Method to be called relative to the event type\n * @param {Object} message - Data received from the websocket\n * @param {Object} instance - SocketService class instance\n * @param {string} event - Type of socket event receive\n *\n * @returns {*} Response from the action method\n */\nconst checkCallEvent = (action, message, instance, event) => {\n  return checkCall(action, message, instance, event)\n}\n\n/**\n * Calls internal and custom actions with the received message and SocketService class instance\n * @function\n * @private\n *\n * @param {Object} instance - SocketService class instance\n * @param {string} event - Type of socket event receive\n * @param {function} action - Method to be called relative to the event type\n * @param {Object} message - Data received from the websocket\n *\n * @returns {void}\n */\nconst callAction = (instance, event, action) => {\n  const eventName = camelCase((event.split(':')[1] || '').toLowerCase())\n\n  return data => {\n    if (!eventName) return instance.logData(`Invalid event name!`, event)\n\n    // Parse the data from string to object\n    const message = data && JSON.parse(data)\n\n    // Log the event for debugging\n    instance.logEvent(event, message)\n\n    // Look for the init event, and pull out the commands from it\n    // Init should only happen when we connect to the socket\n    eventName === 'init' && (instance.commands = get(message, 'data.commands'))\n\n    // Call the default internal action if it exists\n    const internal = InternalActions[eventName]\n    internal && checkCallEvent(internal, message, instance, event)\n\n    // Call the custom action if it exists\n    const customEvent = get(instance.config, `events.${eventName}`)\n    customEvent && checkCallEvent(customEvent, message, instance, event)\n\n    // Call the all action if it exists\n    // Is called for all sockr events that happen on the frontend\n    const allEvent = get(instance.config, `events.all`)\n    allEvent && checkCallEvent(allEvent, message, instance, event)\n  }\n}\n\n/**\n * Find the command from the commands ID\n * Searches through all loaded command, looking for a matching id\n * Otherwise returns false\n * @function\n * @private\n *\n * @param {Object} commands - All commands loaded from the back end\n * @param {Object|string} cmdOrId - Command object or id of the command\n *\n * @returns {Object|boolean} - The found command object or false\n */\nconst getCommand = (commands, cmdOrId) => {\n  const cmdId = isObj(cmdOrId) ? cmdOrId.id : cmdOrId\n\n  return Object.entries(commands).reduce((found, [ group, subCmds ]) => {\n    return found\n      ? found\n      : Object.entries(subCmds).reduce((subFound, [ name, definition ]) => {\n        return !subFound && isObj(definition) && definition.id === cmdId\n          ? definition\n          : subFound\n      }, false)\n  }, false)\n}\n\n/**\n * Service class for managing client websocket events\n * @function\n * @private\n *\n * @param {Object} config - Websocket client config object matching the config spec\n * @param {function} dispatch - Method to be called to update the websocket state\n * @param {string} token - Auth token for connecting to the websocket\n *\n * @returns {Object} - Instance of SocketService\n */\nexport class SocketService {\n  /**\n   * Helper to log data when logDebug is true\n   * @memberof SocketService\n   * @type function\n   * @public\n   * @param {*} data - Items to be logged\n   *\n   * @returns {void}\n   */\n  logData(...data) {\n    this.logDebug && console.log(...data)\n  }\n\n  /**\n   * Helper to log events when logDebug is true\n   * @memberof SocketService\n   * @type function\n   * @public\n   * @param {string} event - Websocket event to be logged\n   * @param {*} data - Items to be logged\n   *\n   * @returns {void}\n   */\n  logEvent(event, ...data) {\n    this.logDebug && console.log(`Socket Event: ${event}`, ...data)\n  }\n\n  /**\n   * Initializes the web-socket based on the passed in config\n   * Starts initial handshake to connect with the backend\n   * @memberof SocketService\n   * @type function\n   * @public\n   *\n   * @param {Object} config - Options for setting up the websocket\n   * @param {string} token - Auth token for validating with the backend\n   * @param {boolean} logDebug - Should log Socket events as the happen\n   *\n   * @returns {void}\n   */\n  initSocket(config, token, logDebug = false) {\n    // If the sockets already setup, just return\n    if (this.socket) return\n\n    this.config = config\n    this.logDebug = logDebug\n\n    const endpoint = buildEndpoint(config)\n\n    this.logData(`Connecting to backend socket => ${endpoint}${config.path}`)\n\n    // Setup the socket, and connect to the server\n    this.socket = io(endpoint, {\n      path: config.path,\n      transports: [ 'websocket', 'polling', 'flashsocket' ],\n    })\n\n    this.addEvents(token)\n  }\n\n  /**\n   * Initializes the web-socket based on the passed in config\n   * Starts initial handshake to connect with the backend\n   * @memberof SocketService\n   * @type Object\n   * @public\n   *\n   * @param {Object} config - Options for setting up the websocket\n   * @param {string} token - Auth token for validating with the backend\n   * @param {boolean} logDebug - Should log Socket events as the happen\n   *\n   * @returns {void}\n   */\n  addEvents(token) {\n    if (!this.socket) return\n\n    // Map the custom config.events with valid actions\n    // To listeners on the websocket\n    // Skip if an event type matching an internal event\n    // Custom event types with the same name as internal event\n    // Get called within the callAction of the registered internal event\n    Object.entries(get(this.config, 'events', noOpObj)).map(\n      ([ name, action ]) => {\n        const namCaps = snakeCase(name).toUpperCase()\n        if (namCaps === 'ALL') return\n\n        const eventType = `${tagPrefix}:${namCaps}`\n\n        isFunc(action) &&\n          !EventTypes[namCaps] &&\n          this.socket.on(eventType, callAction(this, eventType))\n      }\n    )\n\n    // Socket Map Event types to internal actions\n    Object.entries(EventTypes).map(([ key, eventType ]) => {\n      this.socket.on(eventType, callAction(this, eventType))\n    })\n\n    // Initial connection to the server through the socket\n    // Call the onConnection method which will handel authorization\n    this.socket.on(`connect`, this.onConnection.bind(this, token))\n  }\n\n  /**\n   * Callback method called when the websocket connects to the backend\n   * @memberof SocketService\n   * @type function\n   * @public\n   * @param {string} token - Auth token for validating with the backend\n   * @param {Object} data - Content sent from the backend\n   *\n   * @returns {void}\n   */\n  onConnection(token, data) {\n    // TODO: Implement token auth\n    // Send the token to the server to be validated\n    // this.emit(EventTypes.AUTH_TOKEN, { token: token })\n    // Then call the `callAction` with the connected event args\n    const connectAction = callAction(this, `${tagPrefix}:CONNECT`)\n    connectAction(data)\n  }\n\n  /**\n   * Sends an event to the connected backend through websocket ( Like an REST API call )\n   * @memberof SocketService\n   * @type function\n   * @public\n   * @param {string} event - Name of the event to emit ( Sent to the backend )\n   * @param {Object} data - Content sent to the backend\n   *\n   * @returns {void}\n   */\n  emit = (event, data) => {\n    if (!this.socket)\n      return console.error(`Socket not connected, cannot emit socket event!`)\n\n    if (!event)\n      return console.error(\n        `Event type is missing, cannot emit socket event without an event type!`,\n        event\n      )\n\n    this.logData(`Sending Socket Event: ${event}`, data)\n\n    // Send a message to the server\n    this.socket.emit(event, data)\n  }\n\n  /**\n   * Builds the command to be run, and sends it to the backend\n   * @memberof SocketService\n   * @type function\n   * @public\n   * @param {Object|string} command - Command data used to build the command for the backend\n   *                                  Or the id of the command to be run\n   *\n   * @returns {void}\n   */\n  runCommand(command, params) {\n    const { id, cmd, name, group } = getCommand(this.commands, command)\n    return this.emit(EventTypes.RUN_CMD, {\n      id,\n      cmd,\n      name,\n      group,\n      params,\n    })\n  }\n\n  /**\n   * Disconnects from the backend websocket\n   * Cleans up any open object || handles\n   * @memberof SocketService\n   * @type function\n   * @public\n   *\n   * @returns {void}\n   */\n  disconnect = () => {\n    if (!this.socket) return this.logData(`Socket already disconnected!`)\n\n    this.logData(`Disconnecting from Socket!`)\n    this.socket.disconnect()\n    this.socket = undefined\n    this.config = undefined\n    this.dispatch = undefined\n  }\n}\n\nexport const WSService = new SocketService()\n","import { noOpObj } from '@keg-hub/jsutils'\nimport { EventTypes } from '../../constants/eventTypes'\n\n/**\n * Initial state of the sockr reducer\n * @type Object\n */\nconst initialState = {\n  connected: false,\n  peers: [],\n  id: null,\n  runningCmd: null,\n  isRunning: false,\n  server: noOpObj,\n  events: noOpObj,\n}\n\n/**\n * Default reducer for sockr\n * @type function\n * @public\n * @export\n * @param {Object} [state=initialState] - Initial state of the reducer\n * @param {Object} action - Properties define how to update the current reducer state\n *\n * @returns {Object} Reducers state with the actions updates applied\n */\nexport const sockrReducer = (state = initialState, action) => {\n  if (!state || !action || !action.type) return state\n\n  switch (action.type) {\n  case EventTypes.CONNECT: {\n    return action.connected === state.connected\n      ? state\n      : {\n          ...state,\n          connected: true,\n        }\n  }\n\n  case EventTypes.SET_ID: {\n    const { type, ...updates } = action\n    return !action.id\n      ? state\n      : {\n          ...state,\n          ...updates,\n        }\n  }\n\n  case EventTypes.RUNNING: {\n    return action.isRunning === state.isRunning\n      ? state\n      : {\n          ...state,\n          runningCmd: (action.isRunning && action.name) || null,\n          isRunning: action.isRunning,\n        }\n  }\n\n  case EventTypes.ADD_PEER: {\n    return !action.peers\n      ? state\n      : {\n          ...state,\n          peers: action.peers,\n        }\n  }\n\n  case EventTypes.DISCONNECT_PEER: {\n    return !action.peers\n      ? state\n      : {\n          ...state,\n          peers: action.peers,\n        }\n  }\n\n  default: {\n    return state\n  }\n  }\n}\n","/**\n * Cache holder for the joined reducers function\n * @type function\n * @private\n */\nlet _JOINED_REDUCERS\n\n/**\n * Joins the custom reducer method with the default sockr reducer\n * @function\n * @public\n * @export\n * @param {function} sockrReducer - Default sockr reducer\n * @param {function} customReducer - Custom reducer passed in by the sockr consumer\n *\n * @returns {function} Single reducer function\n */\nexport const joinReducers = (sockrReducer, customReducer) => {\n  // If the joined reducers are already set, just return them\n  if (_JOINED_REDUCERS) return _JOINED_REDUCERS\n\n  // Set the join reducer function, then return it\n  _JOINED_REDUCERS = (state, action) => {\n    const updatedState = sockrReducer(state, action)\n    return customReducer(updatedState, action)\n  }\n\n  return _JOINED_REDUCERS\n}\n","import { useReducer } from 'react'\nimport { sockrReducer } from './sockrReducer'\nimport { joinReducers } from './joinReducers'\nimport { deepMerge } from '@keg-hub/jsutils'\nimport { getDispatch, getState, setNextState, setDispatch } from './sockrState'\n\n/**\n * Call the sockr reducer to get the initial state\n * @object\n */\nconst initialState = sockrReducer()\n\n// Set the initial sate to the sockrState object\nsetNextState(initialState)\n\n/**\n * Hook to setup the sockr reducer and initialize the sockr state\n * Also joins the custom reducer and state with the defaults\n * @function\n * @public\n * @export\n * @param {function} customReducer - Custom reducer passed in by the sockr consumer\n * @param {Object} customInitialState - Custom initial state to override the defaults\n *\n * @returns {function} Single reducer function\n */\nexport const useSockrReducer = (customReducer, customInitialState) => {\n  // Join the reducers if a custom reducer is passed in\n  // And build the reducers with the joined default state and custom state\n  const [ state, dispatch ] = useReducer(\n    joinReducers(sockrReducer, customReducer),\n    deepMerge(initialState, customInitialState)\n  )\n\n  // Update the internal state so we can keep track of it\n  getState() !== state && setNextState(state)\n\n  // Technically the dispatch method should never change, so no need to memoize\n  getDispatch() !== dispatch && setDispatch(dispatch)\n\n  return state\n}\n","import { WSService } from '../service'\nimport { SocketContext } from './context'\nimport { noOpObj } from '@keg-hub/jsutils'\nimport React, { useEffect } from 'react'\nimport { useSockrReducer } from '../reducer/useSockrReducer'\n\nconst isDev = process.env.NODE_ENV === 'development'\n\n/**\n * Component to memoize the children of the context provider\n * @function\n * @private\n * @param {Object} props\n * @param {function} props.children - Children components passed to the Provider\n *\n */\n// eslint-disable-next-line no-unused-vars\nconst MemoChildren = React.memo(props => <>{props.children}</>)\n\n/**\n * Websocket Provider component. Should wrap a react application as a Provider\n * @function\n * @public\n * @export\n * @param {Object} props\n * @param {function} props.reducer - Custom websocket reducer function\n * @param {Object} props.initialState - Custom initial state for the reducer\n *\n * @returns {Object} sockr model object\n */\nexport const SockrProvider = props => {\n  const { children, config, reducer, token, debug } = props\n\n  const websocket = useSockrReducer(reducer, config || noOpObj)\n\n  // Only init the websocket on initial render\n  // Don't update the websocket after that\n  // All config values must be setup from the start\n  useEffect(() => {\n    WSService &&\n      !WSService.socket &&\n      WSService.initSocket(websocket, token, debug)\n\n    return () => !isDev && WSService.disconnect()\n  }, [])\n\n  return (\n    <SocketContext.Provider value={websocket}>\n      <MemoChildren>{children}</MemoChildren>\n    </SocketContext.Provider>\n  )\n}\n","module.exports = {\n  ...require('./eventTypes'),\n}\n","export * from './hocs'\nexport * from './hooks'\nexport * from './context'\nexport * from './service'\n\nimport Constants from '../constants'\nconst { EventTypes, tagPrefix } = Constants\n\nexport { EventTypes, tagPrefix }\n"],"names":["SocketContext","React","createContext","useSockr","useContext","SockrHoc","Component","websocket","props","_SOCKR_STATE","_SOCKR_DISPATCH","console","warn","getState","getDispatch","setNextState","next","useSockrItems","findPaths","noPropArr","statePaths","eitherArr","state","values","useMemo","reduce","found","valPath","get","sockrRef","useRef","clearObj","current","Object","entries","map","key","value","deepFreeze","require","module","EventTypes","INIT","SET_ID","CONNECT","UPDATE_STORE","AUTH_TOKEN","NOT_AUTHORIZED","ADD_PEER","PEER_DISCONNECT","SET_CMDS","RUN_CMD","CMD_RUNNING","CMD_END","CMD_OUT","CMD_ERR","CMD_FAIL","tagPrefix","setId","id","data","isRunning","type","setCmds","commands","peers","noOpObj","service","connected","message","DISCONNECT_PEER","name","RUNNING","checkCallEvent","action","instance","event","checkCall","callAction","eventName","camelCase","split","toLowerCase","logData","JSON","parse","logEvent","internal","InternalActions","customEvent","config","allEvent","SocketService","this","socket","emit","error","disconnect","undefined","dispatch","logDebug","log","initSocket","token","endpoint","protocol","window","port","host","buildEndpoint","path","io","transports","addEvents","namCaps","snakeCase","toUpperCase","eventType","isFunc","on","onConnection","bind","connectAction","runCommand","command","params","cmd","group","cmdOrId","cmdId","isObj","subCmds","subFound","definition","getCommand","WSService","initialState","runningCmd","server","events","sockrReducer","updates","_JOINED_REDUCERS","useSockrReducer","customReducer","customInitialState","useReducer","updatedState","joinReducers","deepMerge","setDispatch","isDev","process","env","NODE_ENV","MemoChildren","memo","children","SockrProvider","reducer","debug","useEffect","Provider","Constants"],"mappings":"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"}